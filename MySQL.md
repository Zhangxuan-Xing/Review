<!-- GFM-TOC -->
* [一、架构介绍](#一架构介绍)
* [二、索引优化](#二索引优化)
* [三、查询截取](#三查询截取)
* [四、锁的机制](#四锁的机制)
* [五、主从复制](#五主从复制)
<!-- GFM-TOC -->


# 一、架构介绍

## 逻辑架构  
  
**总体概览**  
  
**1.Connectors**  
指的是不同语言中与SQL的交互 
   
**2 Management Serveices 和 Utilities**  
系统管理和控制工具  
  
**3 Connection Pool（连接池）**   
管理缓冲用户连接，线程处理等需要缓存的需求  
  
负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块 
   
每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务  
  
连接线程的主要工作就是负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等  
  
**4 SQL Interface（SQL接口）**  
接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface  
     
**5 Parser（解析器）**  
SQL命令传递到解析器的时候会被解析器验证和解析 
     
解析器是由Lex和YACC实现的，是一个很长的脚本  
   
在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块  
  
主要功能：  
a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的  
b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的  
 
**6 Optimizer（查询优化器）**  
SQL语句在查询之前会使用查询优化器对查询进行优化  
优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果    
  
使用的是“选取-投影-联接”策略进行查询：  
       用一个例子就可以理解： select uid,name from user where gender = 1;  
       这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤  
       这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤  
       将这两个查询条件联接起来生成最终查询结果  
  
**7 Cache和Buffer（查询缓存）**  
他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的  
  
如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等  
  
**8 存储引擎接口**  
存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色  
  
     MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎  
  
MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发  
  
     **注意：存储引擎是基于表的，而不是数据库** 

## 存储引擎  
**查询命令**  
show create table test  
  
**MyISAM  和  InnoDB**  
  
|区别比较|MyISAM|InnoDB|  
|:--|:--|:--|  
| 构成 | 每个MyISAM在磁盘上存储成三个文件。第一个 文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩 展名是.MYI (MYIndex) | 基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB |  
| 事务处理 | MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持 | InnoDB提供事务支持事务，外部键等高级数据库功能 |  
| SELECT UPDATE INSERT Delete | 如果执行大量的SELECT，MyISAM是更好的选择 | 1.如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表；2.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除；3.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用 |  
| 对 AUTO_INCREMENT 的操作 | 每表一个AUTO_INCREMEN列的内部处理  MyISAM为INSERT和UPDATE操作自动更新这一列。这使得AUTO_INCREMENT列更快（至少10%）  在序列顶的值被删除之后就不 能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列  可以出现重使用从序列顶部删除的值的情况）  AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引更好和更快的auto_increment处理 | 如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数 器的计数器，它被用在为该列赋新值自动增长计数器仅被存储在主内存中，而不是存在磁盘上 | 
| 具体行数 | select count(*) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的 | InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行 |  
| 锁 | 表锁 | 提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句，MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%” |   
  
**如何选择**  
  
MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。  
  
虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个  
   
两种存储引擎的大致区别表现在：  
1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了  
2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用  
3）InnoDB支持外键，MyISAM不支持  
4）从MySQL5.5.5以后，InnoDB是默认引擎  
5）InnoDB不支持FULLTEXT类型的索引  
6）InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表  
7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引  
8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表  
9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'  

**关于MyISAM与InnoDB选择使用**  
  
MYISAM和INNODB是Mysql数据库提供的两种存储引擎。两者的优劣可谓是各有千秋。INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MYISAM不支持。MYISAM的性能更优，占用的存储空间少。所以，选择何种存储引擎，视具体应用而定：   
1）如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句  
2）如果你的应用程序对查询性能要求较高，就要使用MYISAM了。MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率  
  
有人说MYISAM只能用于小型应用，其实这只是一种偏见  
如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎  
  
*Tip：*  现在一般都是选用innodb了，主要是myisam的全表锁，读写串行问题，并发效率锁表，效率低myisam对于读写密集型应用一般是不会去选用的。  
   
**默认引擎**  
  
MyISAM和InnoDB是MySQL的两种存储引擎  
如果是默认安装，那就应该是InnoDB，你可以在my.cnf文件中找到default-storage-engine=INNODB；也可以在建表时指定相应的存储引擎  
  
**基本差别**  
  
1）MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持  
2）MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能  
  

## 配置文件   
  
**二进制日志log-bin**  
主重复制  
  
**错误日志log-error**  
默认是关闭的,记录严重的警告和错误信息,每次启动和关闭的详细信息等  
  
**查询日志log**  
默认关闭,记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源的  
  
**数据文件**  
1）frm文件  
存放表结构  
2）myd文件  
存放表数据  
3）myi文件   
存放表索引  
   
# 二、索引优化  
  
## 问题分析  
  
**可能存在的问题：**  
1）性能下降SQL慢  
2）执行时间长   
3）等待时间长    
  
**与之对应的可能原因：**  
1）查询语句写的烂  
2）索引失效   
3）关联查询太多join(设计缺陷或不得已的需求)  
4）服务器调优及各个参数设置(缓冲\线程数等)    
  
## 索引简介  
  
**是什么**  
MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构  
  
**可以得到索引的本质：索引是数据结构  -  可以简单理解为"排好序的快速查找数据结构"**  
  
**结论：**   数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引  
  
一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上  
  
我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等  
  
**优势**   

- 类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本  

- 通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗
  
**劣势**   

- 实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的  

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息  

- 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句  
  
**索引分类**  

- 单值索引:即一个索引只包含单个列，一个表可以有多个单列索引  

- 唯一索引:索引列的值必须唯一，但允许有空值  

- 复合索引:即一个索引包含多个列  
   
**基本语法**  

- 创建  
CREATE [UNIQUE] INDEX  indexName ON mytable(columnname(length))  
[如果是CHAR,VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length]  
ALTER mytable ADD [UNIQUE]  INDEX [indexName] ON(columnname(length))  
  
- 删除  
DROP INDEX [indexName] ON mytable  
  
- 查看
SHOW INDEX FROM table_name\G    
  
- ALTER命令  


**索引结构**  
1）BTree索引  
Btree索引(或Balanced Tree)，是一种很普遍的数据库索引结构，oracle默认的索引类型（本文也主要依据oracle来讲）。其特点是**定位高效、利用率高、自我平衡**，特别适用于高基数字段，定位单条或小范围数据非常高效。理论上，使用Btree在亿条数据与100条数据中定位记录的花销相同。  
  
2）Hash索引    
3）full-text全文索引  
4）R-Tree索引  
   
**适合建索引的场景**  
1）主键自动建立唯一索引  
2）频繁作为查询的条件的字段应该创建索引  
3）查询中与其他表关联的字段，外键关系建立索引  
4）频繁更新的字段不适合创建索引  
5）Where条件里用不到的字段不创建索引  
6）单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）  
7）查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度  
8）查询中统计或者分组字段   
   
**不适合建索引的场景**   
1）表记录太少  
2）经常增删改的表  
3）数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引  
*Tip：*  如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果  
  
## 性能分析   
  
**MySQL常见瓶颈**  

- CPU:CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候  

- IO:磁盘I/O瓶颈发生在装入数据远大于内存容量时  

- 服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态  
  
**性能详解**  

- 是什么  
使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈  

- 能知道什么  
1）表的读取顺序  
2）数据读取操作的操作类型  
3）哪些索引可以使用  
4）哪些索引被实际使用  
5）表之间的引用  
6）每张表有多少行被优化器查询  

- 怎么用  
第一步：Explain+SQL语句  
第二部：查看执行计划包含的信息  

- 字段解释  

**1）id**   
select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序  
  
三种情况：  
1.id相同，执行顺序由上至下  
2.id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行  
3.id相同不同，同时存在  
  
**2）select_type**  
查询的类型，主要用于区别 普通查询、联合查询、子查询等的复杂查询  
**1.SIMPLE**：简单的select查询，查询中不包含子查询或者UNION  
**2.PRIMARY**：查询中若包含任何复杂的子部分，最外层查询则被标记  
**3.SUBQUERY**：在SELECT或者WHERE列表中包含了子查询  
**4.DERIVED**：在FROM列表中包含的子查询被标记为DERIVED（衍生）  -   MySQL会递归执行这些子查询，把结果放在临时表里  
**5.UNION**：若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 DERIVED  
**6.UNION RESULT**：从UNION表获取结果的SELECT  
  
**3）table** 
显示这一行的数据是关于哪张表的
  
**4）type**  
显示查询使用了何种类型，从最好到最差依次是：  
system>const>eq_ref>ref>range>index>ALL  
  
system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计  
const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量  
eq_ref：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描  
ref:非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体  
range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引,一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束语另一点，不用扫描全部索引  
index：Full Index Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）  
all：FullTable Scan,将遍历全表以找到匹配的行  
  
备注：一般来说，得保证查询只是达到range级别，最好达到ref  
  
**5）possible_keys**  
显示可能应用在这张表中的索引,一个或多个  
查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用  
  
**6）key**  
实际使用的索引。如果为null则没有使用索引  
查询中若使用了覆盖索引，则索引和查询的select字段重叠  
  
**7）key_len**  
表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好  
key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的  
  
**8）ref**  
显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值  
  
**9）rows**  
根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数  
  
**10）Extra**  
包含不适合在其他列中显示但十分重要的额外信息  
  
**1.Using filesort**  
说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作成为“文件排序”  
**2.Using temporary**   
使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by  
**3.USING index**   
表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！
如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表面索引用来读取数据而非执行查找动作[覆盖索引（Covering Index)]  
**4.Using where**   
表面使用了where过滤  
**5.using join buffer**  
使用了连接缓存  
**6.impossible where**  
where子句的值总是false，不能用来获取任何元组  
**7.select tables optimized away**  
在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化  
**8.distinct**  
优化distinct，在找到第一匹配的元组后即停止找同样值的工作  
  
## 索引优化  
  
**索引失效情况**  
    
1.全值匹配我最爱  
  
2.最佳左前缀法则：如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列  
  
3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描  
  
4.存储引擎不能使用索引中范围条件右边的列  
  
5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*  
  
6.mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描  
  
7.is null,is not null 也无法使用索引  
  
8.like以通配符开头（'$abc...'）mysql索引失效会变成全表扫描操作  
  
9.字符串不加单引号索引失效  
  
10.少用or,用它连接时会索引失效  
  
**问题：解决like'%字符串%'索引不被使用的方法？**   
1 可以使用主键索引  
2 使用覆盖索引，查询字段必须是建立覆盖索引字段  
3 当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效  
  
**注意：like KK%相当于=常量；%KK和%KK% 相当于范围**   
  
**备忘录**   
定值、范围还是排序，一般order by是给个范围  
group by 基本上都需要进行排序，会有临时表产生  
  
**建议**  

- 对于单键索引，尽量选择针对当前query过滤性更好的索引  

- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好  

- 在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引  

- 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的  

  
# 三、查询截取  
  
**查询优化**  
  

##  永远小表驱动大表   ##
类似嵌套循环Nested Loop  

## ORDER BY关键字优化 ##
**1）ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序**  
MySQL支持二种方式的排序，FileSort和Index,Index效率高，它指MySQL扫描索引本身完成排序，FileSort方式效率较低  
  
ORDER BY满足两情况，会使用**Index方式排序**：  
1.ORDER BY语句使用索引最左前列  
2.使用where子句与OrderBy子句条件列组合满足索引最左前列  
  
**2）尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀**  
  
**3）如果不在索引列上，filesort有两种算法**  
mysql就要启动双路排序和单路排序  
**双路排序**：MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输。从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。  
  
**单路排序**：取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。  
从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。  
  
**不绝对结论：**  
由于单路是后出来的，总体而言好过双路  
但是用单路有问题
  
**4）优化策略**  

- 增大sort_buffer_size参数的设置  

- 增大max_length_for_sort_data参数的设置

## GROUP BY关键字优化   

- groupby实质是先排序后进行分组，遵照索引建的最佳左前缀  

- 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置  

- where高于having,能写在where限定的条件就不要去having限定了  
  
**慢查询日志**  

- 查看是否开启及如何开启  
默认：SHOW VARIABLES LIKE '%slow_query_log%'  
开始：SET GLOBAL slow_query_log = 1  

- 查看当前多少秒算慢  
SHOW VARIABLES LIKE 'long_query_time%'  

- 设置慢的阙值时间  
SET GLOBAL long_query_time=3  

- 为什么设置后看不出变化  
需要重新连接或者新开一个回话才能看到修改值  
SHOW VARIABLES LIKE 'long_query_time%'  
SHOW GLOBAL VARIABLES LIKE 'long_query_time'  
  
- 日志分析工具MYSQLDUMPSHOW  
查看MYSQLDUMPSHOW的帮助信息  
s:是表示按何种方式排序  
c:访问次数  
l:锁定时间  
r:返回记录  
t:查询时间  
al:平均锁定时间  
ar:平均返回记录数  
at:平均查询时间  
t:即为返回前面多少条的数据  
g:后边搭配一个正则匹配模式，大小写不敏感的  
  
**批量数据脚本**  
  
例如往表里插入1000W数据  
1.建表  
2.设置参数log_trust_function_createors  
3创建函数保证每条数据都不同
4.创建存储过程  
5.调用存储过程    
  
**Show profiles**  
  

- 是什么  
MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量  

- 官方文档  
http://dev.mysql.com/doc/refman/5.5/en/show-profile.html  
  

**全局查询日志**  
配置启用 - 编码启用  
**永远不要在生产环境开启这个功能**  
  
  
# 四、锁的机制  
  
## 锁的分类   

- 从数据操作的类型（读、写）分

1.读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响  
2.写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁  

- 从对数据操作的颗粒度分
1.表锁  
2.行锁  
  

## 表锁  
偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低  
  
## 行锁 
偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高  
  
**InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁**   
  

- 优化建议
尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁  
  
合理设计索引，尽量缩小锁的范围  
  
尽可能较少检索条件，避免间隙锁  
  
尽量控制事务大小，减少锁定资源量和时间长度  
  
尽可能低级别事务隔离  
   
## 页锁  
开销和加锁时间界于表锁和行锁之间：会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  
  

# 五、主从复制  

**基本原理**  
slave会从master读取binlog来进行数据同步  
  
master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志时间，binary log events  
slave将master的binary log ebents拷贝到它的中继日志（relay log）  
slave重做中继日志中的时间，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的  
  
**基本原则**  
每个slave只有一个master  
每个slave只能有一个唯一的服务器ID  
每个master可以有多个salve  
  
**最大问题**  
延时  
  
**其他**  
停止从服务复制功能：stop slave;

