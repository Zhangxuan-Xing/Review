<!-- GFM-TOC -->
* [一、Spring核心](#一Spring核心)  
* [二、装配Bean](#二装配Bean)  
* [三、高级装配](#三高级装配) 
* [四、面向切面](#四面向切面)  
<!-- GFM-TOC -->

# 一、Spring核心
- Spring功能的底层依赖于两个核心特性：依赖注入DI和面向切面编程AOP

- 相对于EJB来说，Spring提供了更加轻量级和简单的编程模型

- Spring用Bean或者JavaBean来表示应用组件，但并不意味着Spring组件必须要遵循JavaBean规范，一个Spring组件可以是任何形式的POJO

- Spring最根本的使命：简化Java开发

- 为降低Java开发的复杂性，Spring采取了以下4中关键策略：
 - 基于POJO的轻量级和最小侵入性编程
 - 通过依赖注入和面向接口实现松耦合
 - 基于切面和惯例进行声明式编程
 - 通过切面和模板减少样板式代码

- Struts、WebWork等框架都是侵入式编程，容易导致应用于框架绑死

- Spring 的非侵入式编程模型意味着在Spring和非Spring应用中都可以发挥同样作用

- Spring赋予POJO的魔力的方式之一就是通过DI来装配它们

- 耦合具有两面性，紧密耦合的代码难以测试、复用、理解，但一定的程度的耦合又是必须的，完全没有耦合的代码什么也做不了

- 通过DI，对象的依赖关系由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系（**松耦合**）

- 创建应用组件之间协作的行为通常称为装配

- Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来，Spring应用上下文全权负责对象的创建和组装

- DI能让相互协作的软件组件保持松散耦合，面向切面编程允许你把遍布在应用各处的功能分离出来形成可重用的组件

- AOP也可以定义为 促使软件系统实现关注点分离的一项技术

- AOP 能确保POJO的简单性：使服务模块化，以声明的方式将它们应用到它们需要影响的组件中去，这些组件会有更高的内聚性并更关注自身的业务，完全不需要了解系统服务的复杂性

- Spring旨在通过模板封装来消除样板式代码：诸如JDBC JMS JNDI REST服务

- Spring容器：应用中所有bean所驻留的地方（bean可以理解为类的代理或代言人 反射实现）

- Spring容器不只有一个，可以归为两种不同的类型：bean工厂-最简单的容器，提供基本的DI支持；应用上下文-基于BeanFactory构建，提供应用框架级别的服务
  
 --- 
# 二、装配Bean  
  
- 在Spring中，对象无需自己查找或创建与其所关联的其他对象，容器负责把需要相互协作的对象引用赋给各个对象

- 创建应用对象之间协作关系的行为通常称为装配，也是DI的本质

- Spring提供三种主要装配机制：XML\JAVA\隐式的bean发现机制和自动装配

- Spring 的自动化装配主要是从两个角度来实现的：组件扫描（发现在应用上下文中创建的bean）、自动装配（自动满足bean之间的依赖）

- @Component 表明该类会作为组件类，并告知Spring要为这个类创建bean

- Spring应用上下文所有的bean都会给定一个ID，默认是将类名的第一个字母变小写

- 自动装配注解 @Autowired，不仅能用在构造器上，还能用在属性的Setter方法上

- Spring框架的核心是Spring容器，容器负责管理应用中组件的生命周期，会创建这些组件并保证它们的依赖能得到满足

- 尽可能使用自动化配置，避免显式配置所带来的维护成本。如果显式配置，应该优先选择基于Java的配置，比XML的配置更强大、类型安全并且易于重构
  
 --- 
# 三、高级装配  
  
- JNDI：Java命名和目录接口，提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互（数据库DataSource为典型案例）

- Spring引入了bean profile的功能，要使用profile，首先将所有不同的bean定义整理到一个或多个profile中，可以等到运行时确定使用哪一个

- 可以在方法级别上使用@Profile，没有指定profile的bean始终都会被创建，与激活哪个profile没有关系

- Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active
和spring.profiles.default

- profile使用的可以是复数形式，可以同时激活多个profile，以逗号分隔来实现

- 注解@Conditional：如果给定的条件计算结果为true，就会创建这个bean，否则bean会被忽略

- 要注意处理自动装配的歧义性：仅有一个bean匹配所需结果时，自动装配才是有效的。如果不仅有一个bean能匹配结果的话，这种歧义会阻碍Spring自动装配属性、构造器参数或方法参数。如果Spring无法做出选择，会抛出NoNniqueBeanDefinitionException

- 针对上述情况，可以将某一个设为首选（primary），或者使用限定符（qualifier）来帮助缩小范围。如果标记了两个或者更多的首选bean，将无法正常工作

- 自定义的注解更为安全

- 在默认情况下，Spring 应用上下文所有bean都是作为单例的形式创建的（不管给定的一个bean被注入到其他bean多少次，额每次所注入的都是同一个实例）

- 如果所使用的类是易变的，会保持一些状态，重用便容易不安全，将class声明为单例就不是好主意了，对象会被污染

- Spring 定义了多种作用域：单例、原型、会话、请求（@Scope）

- Spring提供了两种在运行时求值的方式：属性占位符、Spring表达式语言

- 处理外部值最简单的方式就是声明属性源并通过Spring的Environment来检索属性

- SpEL特性：  
 1. 使用bean的ID来引用bean
 2. 调用方法和访问对象的属性
 3. 对值进行算术、关系和逻辑运算
 4. 正则表达式匹配
 5. 集合操作
  
 --- 
# 四、面向切面  
  
- 散布于应用中多出的功能被称为横切关注点，从概念上是与应用的业务逻辑相分离的，但是往往直接嵌入业务逻辑中

- 切面能模块化横切关注点，例如安全就是一个横切关注点

- 重用通用功能的最常见技术是继承和委托，继承容易导致脆弱的对象体系，委托需要复杂调用，切面提供了另一个解决方案

- 切面：可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类称为切面

- 切面的优点：关注点集中在一个地方而不是分散到多处代码中，服务模块更简洁

- 描述切面的常用术语：通知、切点、连接点

- 通知：切面的工作，定义了切面是什么以及何时使用（五种类型：前置、后置、返回、异常、环绕）

- 连接点：在应用执行过程中能够插入切面的一个点

- 切点：定义了“何处”，切点的定义会匹配通知所要织入的一个或多个连接点

- 切面：通知和切点的结合

- 织入：把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多个点可以进行织入：编译期、类加载期、运行期（Spring为该方式  AOP容器会为目标对象动态地创建一个代理对象）

- 并不是所有的AOP框架都是相同的，创建切点来定义切面所织入的连接点是AOP框架的基本功能

- Spring提供了四种AOP支持：
 1. 基于代理的经典Spring AOP
 2. 纯POJO切面
 3. @AspectJ注解驱动的切面
 4. 注入式AspectJ切面
- Spring在运行时通知对象：提供代理类包裹切面，当代理拦截方法调用时，在调用目标bean方法之前，会执行切面逻辑。直到应用需要被代理的bean时，才创建代理对象

- Spring只支持方法级别的连接点

- 使用within（）指示器可以限制切点的范围

- Spring 的AspectJ自动代理，依然是Spring基于代理的切面

- 环绕通知是最为强大的通知类型：别忘记调用proceed（）方法，如果不调用这个方法，通知实际上会阻塞被通知方法的调用

 --- 
  
