<!-- GFM-TOC -->
* [一、对象导论](#一对象导论)  
* [二、一切都是对象](#二一切都是对象)  
* [三、操作符](#三操作符)  
* [四、初始化与清理](#四初始化与清理)
* [五、访问权限控制](#五访问权限控制)
* [六、复合类](#六复合类)
* [七、多态](#七多态)
* [八、接口](#八接口)
* [九、数组](#九数组)
* [十、字符串](#十字符串)
* [十一、字符串](#十一内部类)
* [十二、持有对象](#十二持有对象)
* [十三、异常处理](#十三异常处理)
* [十四、类型信息](#十四类型信息)
* [十五、泛型](#十五泛型)
* [十六、容器](#十六容器)
* [十七、I/O系统](#十七I/O系统)
* [十八、枚举](#十八枚举)
* [十九、注解](#十九注解)
<!-- GFM-TOC -->

# 一、对象导论  
  

- 所有编程语言都提供抽象机制。解决问题的复杂性直接取决于抽象的类型和质量。  

- 1）万物皆为对象   
2）程序是对象的集合，它们通过发消息来告诉彼此所要做的   
3）每个对象都有自己的由其他对象所构成的存储（可通过创建包含现有对象的包的方式来创建新的对象）  
4）每个对象都拥有类型  
5）某一特定类型的所有对象都可以接收同样的消息

- 对象具有 状态 行为 和 标识（每一个对象在内存中都有一个唯一的地址）

- 每一个对象都属于定义了特征和行为的某个特定的类  

- 将对象看做是服务提供者，有助于提高对象的内聚性

- protected关键字和private作用相当，差别仅在于继承的类可以访问protect成员，但不能访问private成员

- 继承是否扩展了接口，要注意基类能否访问新添加的方法，区别“is-a”和“like-a”

- 面向对象程序设计语言使用 后期绑定 的概念，被调用的代码直到运行时才能确定

- 在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态

- 终极基类Object，使得在单根继承结构中的所有对象都具有一个共用接口，也使得垃圾回收器的实现变得容易（不会因为无法确定对象的类型而陷入僵局）

- 不同的容器提供了不同类型的接口和外部行为；对于某些操作具有不同的效率

- 向上转型是安全的，即 转为更具体的类型

- Java SE5增加了参数化类型，称为泛型

- Java可以将对象置于堆栈（自动变量或限域变量）或静态存储区域内  
*存储分配和释放很便捷有效，但是缺乏灵活性，在编写时就要确定*  
也可以在堆的内存池中动态的创建对象  
*存储空间是被动态管理的，只能程序运行相关代码被执行到的那一刻才确定*

- Java完全采用了动态内存分配方式（基本类型只是一种特例）

- 垃圾回收器：减少了必须考虑的议题和必须编写的代码；提供了更高层的保障，可以避免暗藏的内存泄漏问题

- 异常是一种对象，但异常处理不是面向对象的特征，提供了一种从错误状况进行可靠恢复的途径
 
--- 
 
# 二、一切都是对象  

- 尽管一切都看作对象，但操作实际上是对象的一个“引用”（如遥控器和电视机），拥有一个引用，并不一定要有一个对象与它相关  
如 String s； 这里所创建的只是引用，并不是对象  
一种安全的做法是，创建一个引用的同时便进行初始化 String s = “goat”；

- 存储位置：  
1）寄存器：最快的存储区，位于处理器内部，数量极其有限  
2）堆栈：对象引用为主，但Java对象并不存储其中  
3）堆：存储所有的Java对象  
4）常量存储：常量值通常直接放在程序代码内部  
5）非RAM存储：数据存活于程序之外，不受程序的控制，程序没有运行时也可以存在，有两个基本的例子为 流对象 和 持久化对象

- 基本类型存储于堆栈中，要注意范围

- BigInteger和BigDecimal：速度取换精度

- Java对象不具备和基本类型一样的生命周期，当用new创建一个对象时，它可以存活于作用域之外

- 若类的某个成员是基本数据类型，即使没有初始化，也会确保它获得一个默认值，但并不适用于“**局部**”变量（即 并非某个类的字段）

- 方法的基本组成部分：名称  参数  返回值  方法体

- 通常来说，当创建类时，就是在描述那个类的对象的外观和行为，除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new创建对象时，数据存储空间才被分配，其方法才供外界调用  

- 当声明一个事物是static时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起，所以即使没创建某个类的任何对象，**也可以访问其static域**

- 一个static字段对于每个类来说都只有一份存储空间，多个对象共享一个static字段，而非static字段则对每个对象都有一个存储空间
  
---

# 三、操作符  

- 几乎所有的操作符都只能操作“基本类型”

- equals（）默认行为是比较引用，大多数Java类库都实现了equals（）方法，用来比较内容而非引用

- ==和=！比较的是引用
  
---

# 四、初始化与清理  

- 从概念来说，“初始化”和“创建”是彼此独立的，但经常捆绑在一起，两者不能分离

- 通过提供构造器，类的设计者可确保每个对象都会得到初始化

- 如果定义了一个构造器（无论是否有参数），编译器不会自动创建默认构造器

- this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用

- 在一个构造器中调用另一个构造器，以避免重复代码，可以用this关键字来实现

- static方法是没有this的方法，在static方法内部不能调用非静态方法，反过来是可以的

- Java垃圾回收器：回收无用对象占据的内存资源，但对象却并非总是被垃圾回收（可能不被垃圾回收）

- 垃圾回收不等于“析构” ，只与内存有关，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存

- 使用finalize（）有一种特殊情况：通过某种创建对象方式以外的方式为对象分配了存储空间，即 本地方法，在Java中调用了非Java的方式

- 不要过多使用finalize（），非进行普通清理工作的合适场所

- Java不允许创建局部对象（也就是在堆栈上创建），必须使用new创建对象；也没有用于释放对象的delete，因为垃圾回收器会帮助释放存储空间

- 如果Java虚拟机（JVM）并未面临内存耗尽的情形，是不会浪费时间去执行垃圾回收以恢复内存的

- finalize（）方法可以用来发现 对象终结条件 情况，可以找出缺陷（如果存在）

- Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美

- 通过垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型

- 引用计数是一种简单但速度很慢的垃圾回收计数，每个对象都含有一个引用计数器，有一个缺陷是如果对象存在循环引用，可能会出现“对象应该被回收，但引用计数却不为零”的情况

- 自适应的垃圾回收计数有  ①停止-复制：先暂停程序的运行（不属于后台回收模式），将所有存活的对象从当前堆复制到另一个堆，没有复制的便全部是垃圾  [复制式回收器，由于堆之间来回倒腾，效率会降低]；②标记-清扫：同样从堆栈和静态存储区出发，遍历所有的引用，进而找出活的对象，给活的对象设一个标记，全部遍历完成后，清理没有标记的对象；

- Java虚拟机中有许多附加技术，新版JDK的HotSpot技术采用了 惰性评估 做法，即时（JIT）编译器只有在必要的时候才编译代码，从而不会被执行的代码就不会被JIT编译，此外，代码每次被执行的时候都会做一些优化，所以执行次数越多，速度就越快

- 初始化应注意顺序，编译器会对“向前引用”发出警告

- 自动初始化将在构造器被调用之前发生，如 int i ；随后在构造器里赋值，也是先被置0，再进行赋值

- 在类的内部，变量定义的先后顺序决定了初始化的顺序；即使变量定义散布于方法定义之间，仍旧在任何方法（包括构造器）被调用之前得到初始化

- 无论创建多少个对象，静态数据都只占用一份存储区域

- static关键字不能应用于局部变量，只能作用于域

- 静态初始化只有在必要时刻才会进行（被创建或第一次访问static静态数据），也就是说，只在对象首次加载的时候进行一次，此后，静态对象不会被再次初始化

- 初始化的顺序是先静态对象（如果尚未因为其他对象创建过程中而被初始化），而后是非静态对象

- 如 int[] a; 现在拥有的是对数组的一个引用，没给数组对象本身分配任何空间

- 如果 int[] b = a； 只是复制了一个引用

- toString（）方法默认行为是打印类的名字和对象的地址

- 使用可变参数列表不依赖于自动包装机制，而实际上使用的是基本类型

- 可变参数列表与自动包装机制可以和谐相处

- ordinal（）方法可以用来表示某个特定enum常量的声明顺序

- enum有一个特别实用的特性，可以在switch中使用  
  
---

# 五、访问权限控制  
  
- 重构（重写代码），可以使代码更可读、更易理解，也具有更高的可维护性

- 权限从大到小为：public 、 protect 、 包访问权限 和 private

- 编译过的代码通常放置在与源代码的不同目录中，但是必须保证JVM使用CLASSPATH可以找到该路径

- 提供访问器（accessor）和变异器（mutator）方法（也就是get/set方法），以读取和改变数值。对于OOP而言，这是最优雅的方式，也是JavaBeans的基本原理

- 如果没有给自己设定任何包名称，Java将这样的文件自动看作是隶属于该目录的默认包中

- 任何可以肯定只是该类的一个“助手”方法的方法，可以指定为private，以确保不会在包内的其他地方误用

- 访问权限，将具体实现进行隐藏

- 每个编译单元都有单一的公共接口，如果在某个编译单元内有一个以上的public类，编译器就会报错

- 单例模式：始终只能创建某类的一个对象
  
---

# 六、复用类  
  
- 复用代码，使用类而不破坏现有程序代码

- 组合：在新的类中产生现有类的对象。通常用于想要在新类中使用现有类的功能而非它的接口这种情形

- 继承：按照现有类的类型来创建对象，采用现有类的形式并在其中添加新代码

- 每一个非基本类型的对象都有一个toString（）方法，当编译器需要一个String而却只有一个对象时，该方法便会被调用

- 继承中，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public

- Java用super关键字来表示超类的意思，当前类就是从超类继承来的

- 继承并不只是复制基类的接口，当创建了一个导出类的对象时，该对象包含了一个基类的子对象，并被包装在导出类对象内部

- 继承调用的顺序是先基类后导出类

- 代理：继承和组合之间的中庸之道

- Java SE5新增了@Override注解，并不是关键字，想要覆写某个方法时，可以选择使用这个注解，可以防止在不想重载时而意外地进行了重载

- 组合和继承都允许在新的类中放置子对象，组合是显示地这样做，而继承是隐式地做

- is-a的关系是用继承来表达的，has-a的关系则是用组合来表达的

- 向上转型：用来表现新类和基类之间的关系，从一个较专用类型向较通用类型转换，是安全的

- final关键字可能用到场景：数据、方法和类

- 一个既是static又是final的域只占据一段不能改变的存储空间

- 定义static，强调只有一份；定义final，强调是一个常量

- 空白final：被声明为final但又未给定初值的域

- 如果参数声明为final，则无法在方法中更改参数引用所指向的对象

- final方法：一是为了把方法锁定，以防任何继承类修改它的含义；二是为了效率，减小开销

- hotSpot技术的出现，使得final方法的效率不具有优势，不需要这优化了

- 如果某方法为private，就不是基类的接口的一部分，仅是一些隐藏于类中的程序代码，private方法无法触及而且能有效隐藏

- 当某个类定义为final时，则不允许继承该类

- 开始一个设计时，一般应优先选择使用组合（或代理），只有确实必要时才使用继承  
  
---

# 七、多态  
      
- 多态通过分离做什么和怎么做，将接口和实现分离开来，且能创建可扩展的程序，消除类型之间的耦合关系

- 多态，也称作 动态绑定、后期绑定或运行时绑定

- 将一个方法调用同一个方法主体关联起来被称作绑定。如果在程序执行前进行绑定，叫做前期绑定；Java中除了static方法和final方法（private方法属于final方法），其他所有的方法都是后期绑定

- 多态是一项“将改变的事物与未变的事物分离开来”的重要技术

- 构造器不同于其他种类的方法，实际上是隐式的static方法

- 基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，使得每个基类的构造器都能得到调用（也能解释调用顺序）

- 复杂对象调用构造器的顺序：①调用基类构造器，从根开始反复递归；②按声明顺序调用成员的初始化方法；③调用导出类构造器的主体

- 通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常留给垃圾回收器处理。如果真的遇到了，销毁顺序与初始化顺序相反，首先对导出类进行清理，然后才是基类

- 编写构造器准则：用尽可能简单的方法使得对象进入正常状态；如果可以的话，避免调用其他方法

- 在构造器内，唯一能安全调用的方法时基类的final方法（包括private方法）

- 基类可以接收发送给导出类的任何消息，因为二者有着完全相同的接口

- 对于继承，也要区别 is-a 和 is-like-a

- 导出类中接口的扩展部分不能被基类访问，一旦向上转型，就不能调用那些新方法

- 多态意味着“不同的形式”  
  
---

# 八、接口  
      
- 接口和内部类提供了一种将接口与实现分离的更加结构化的方法

- 抽象类，是类与接口之间的一种中庸之道

- 通用接口建立起一种基本形式，以此表示所有导出类的共同部分

- Java提供了抽象方法的机制，这种方法时不完整的，仅有声明而没有方法体，语法如 abstract void f（）；

- 包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的

- 如果从一个抽象类继承，并想创建该新类的对象，你们就必须为基类中的所有方法提供方法定义。如果不这样做（实际上可以选择不做），那么导出类也是抽象类，且编译器会强制我们用abstract关键字来限定

- 抽象类是很有用的重构工具，使得程序员可以很容易地将公共方法沿着继承层次结构向上移动

- abstract允许人们在类中创建一个或多个没有任何定义的方法，提供了接口部分，但没有提供具体实现

- interface关键字产生一个完全抽象的类，还允许人们通过创建一个能够向上转型为多种基类的类型，来实现某种类似多重继变种的特性

- 接口被用来建立类与类之间的协议

- 接口可以包含域，这些域隐式地是static和final的

- **interface特点**：  
1.不允许使用访问修饰符（public, private, protected,或者internal）修饰接口成员，所有的接口成员都是公共的；  
2.实现接口的类必须实现接口中的所有的方法；  
3.接口不能定义字段成员，不能用关键字static，virtual，abstract或者sealed来定义接口成员；  
4.不能实例化接口，但接口可以作为字段出现在其他类中，一个类可以实现多个接口，一个接口可以从一个或多个接口继承；
5.实现接口的类可以显式实现该接口的成员。 显式实现的成员不能通过类实例访问，而只能通过接口实例访问。  

- **abstract特点**：  
1.抽象类不能实例化。 抽象类的用途是提供一个可供多个派生类共享的通用基类定义；  
2.抽象类也可以定义抽象方法。 方法是将关键字 abstract 添加到方法的返回类型的前面。抽象方法没有实现，所以方法定义后面是分号，而不是常规的方法块；  
3.抽象类的派生类必须实现所有抽象方法。 当抽象类从基类继承虚方法时，抽象类可以使用抽象方法重写该虚方法；  
4.抽象类是类，所以只能被单继承；  
5.无法使用 sealed 修饰符来修改抽象类，因为两个修饰符具有相反的含义。 sealed 修饰符阻止类被继承，而 abstract 修饰符要求类被继承；  
6.在静态属性上使用 abstract 修饰符是错误的。

- 要实现一个接口时，在接口中被定义的方法必须被定义为public

- 将接口从具体实现中解耦使得接口可以应用于多种的具体实现，因此代码也就更具有复用性

- 一个具体类和多个接口组合到一起时，必须先具体类，后接口

- 如果要创建不带任何方法定义和成员变量的基类，那么应该选择接口而不是抽象类

- 接口最吸引人的原因之一 是允许同一个接口具有多个不同的具体实现

- 放入接口中的任何域都自动是static和final的，且不能是空final，但可以被非常量表达式初始化。此外，这些域，不是接口的一部分，它们的值被存储在该接口的静态存储区域内

- 接口可以嵌套在类或其他接口中

- 在类中嵌套的接口，可以拥有public和包访问两种可视性。如果实现了一个private接口，可以强制该接口中的方法不要添加任何类型信息，换句话说，也就是不允许向上转型

- 嵌套在另一个接口中的接口自动是public，不能声明为private 

- 恰当的原则应当是优先选择类而不是接口。从类开始，如果接口的必需性变得非常明确，那么就进行重构，接口是一种重要的工具，但是容易被滥用
  
---

# 九、数组  

- 数组：可以创建并组装它们，通过使用整型索引值访问它们的元素，并且它们的尺寸不能改变

- 数组和其他种类容器的区别有三方面：效率、类型和保存基本类型的能力

- 数组是效率最高的存储和随机访问对象引用序列的方式

- 数组是线性序列，访问速度很快，但是对象大小被固定

- 数组持有某种具体类型，可以防止插入错误类型和抽取不当类型

- 数组标识符是一个引用，指向堆中创建的真实对象，这个对象用以保存指向其他对象的引用

- []语法是访问数组对象的唯一方式

- 对象数组和基本类型数组在使用上几乎是一样的，唯一区别在于对象数组保存的是引用，基本类型数组直接保存值

- Arrays.deepToString（）方法，将多维数组转换为多个String

- 粗糙数组：数组中构成矩阵的每个向量都可以具有任意的长度

- 通常，数组和泛型不能很好地结合，不能实例化具有参数化类型的数组。  
原因：擦除会移除参数类型信息，而数组必须知道持有的确定类型，以强制保证类型安全  
解决：① 参数化数组本身的类型；② 允许创建对泛型数组的引用，而后进行专心，如   
List<String>[] ls;  
List[] la = new List[10];  
ls = (List<String>[]) la;  

- Arrays的fill（）方法：用同一个值填充各个位置，针对对象而言，就是复制同一个引用进行填充

- 泛型不能用于基本类型，需要是对象类型

- arraycopy（）复制对象数组，只是复制了对象的引用，而不是对象本身的拷贝。不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型

- Collections类包含一个reverseOrder（）方法，可以产生一个Comparator，可以反转自然的排序顺序

- Arrays.binarySearch()如果找到了目标，返回值等于或大于0，负责产生负返回值

- 使用Java中，优选容器而不是数组
  
---

# 十、字符串  
  
- String是不可变的，每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象

- 每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直呆在单一的物理位置上，从未动过

- String对象具有只读性，指向它的任何引用都不可能改变它的值

- 用于String的+和+=是Java仅有的两个重载过的操作符，而Java不允许程序员重载任何操作符。重载：一个操作符在应用于特殊的类时，被赋予了特殊意义

- StringBuilder和StringBuffer，后者是线程安全的，因此开销也会大一些，一般情况下鼓励使用前者

- 当需要改变字符串的内容时，String类的方法都会返回一个新的String对象

- 如果内容没有发生改变，String方法只是返回指向原对象的引用

- foamat方法可以用于PrintStream或PrintWriter

- 在Java中，所有新的格式化功能都由java.util.Formatter类处理，可以看做是一个翻译器，将格式化字符串与数据翻译成需要的结果，并提供了对空格和对齐的强大控制能力

- String.format()是一种static方法，接受与Formatter.format()方法一样的参数，但返回一个String对象，当只需要使用一次的时候，用前者比较方便

- 正则表达式是一种强大而灵活的文本处理工具，也是简洁、动态的语言（P295）

- StringReader将String转化为可读的流对象，然后用这个对象来构造BufferReader对象

- readLine（）方法将一行输入转为String对象，如果两个输入值在同一行，可以用split（）方法来处理

- Scanner的构造器可以接受任何类型的输入对象，包括File对象、InputStream、String或Readable对象

- 在默认情况下，Scannner根据空白字符对输入进行分词

- 基本上来说，StringTokenizer已经被废弃不用了  
  
---

# 十一、内部类  
   
- 内部类，允许把一些逻辑相关的类组织在一起，看起来像是一种代码隐藏机制

- 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个对象的类型：OuterClassName.InnerClassName

- 内部类的对象能访问其外围对象的所有成员或元素，而不需任何特殊情况

- 当某个外部类对象创建了一个内部类对象时，此内部类对象会秘密捕获一个指向那个外围类对象的引用

- 内部类的对象只能在与其外围类的对象相关联的情况下才能被创建

- 创造某个内部类的对象，需要使用.new语法

- 在拥有外部类对象之前是不可能创建内部类对象的，因为内部类对象会暗暗连接到创建它的外部类对象上；如果创建的是嵌套类（静态内部类），就不需要对外部类对象的引用

- 当内部类向上转型为基类，尤其是转型为一个接口时，内部类能很方便的隐藏实现细节

- private内部类完全隐藏了实现的细节

- 在一个方法里面或者在任意的作用域内定义内部类，有两个出发点：  
1）实现了某类型的接口，于是可以创建并返回对其的引用
2）想创建一个类辅助解决复杂问题，但是又不希望这个类是公共可用的

- 局部内部类：在方法的作用域，而不是在其他类的作用域内创建一个完整的类

- 匿名内部类：假如一个局部内部类只被用一次（只用它构建一个对象），就可以不用对其命名了，这种没有名字的类被称为匿名内部类（anonymous inner class）

- 匿名类末尾的分号，并不是用来标记此内部类的结束。标记的是表达式的结束，只不过这个表达式正好包好了匿名内部类

- 如果定义的匿名内部类需要使用一个在外部定义的对象，则参数引用需为final的（如果传递给匿名类的构造器，则不要求一定为final）

- 对于匿名类而言，实例初始化的实际效果就是构造器

- 匿名内部类既可以扩展类，也可以实现接口，但不能两者兼备。如果实现接口，也只能实现一个接口

- 如果不需要内部类对象和外部类对象之间有联系，可以声明为static

- 嵌套类（静态内部类）：
1）要创建嵌套类的对象，并不需要其外部类的对象
2）不能从嵌套类的对象中访问非静态的外围类对象

- 嵌套类没有this引用，类似于一个static方法

- 正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分，放到接口内的任何类都自动地是public和static的

- 内部类能透明地访问所有它所嵌入的外围类的所有成员

- 一般来说，内部类继承自某个类或者实现某个接口，提供了某种进入其外围类的窗口

- 每个内部类都能独立地继承自一个接口的实现，所以无论外部类是否已经继承了接口的实现，对于内部类都没有影响

- 内部类允许继承多个非接口类型

- 内部类有以下主要特性：  
1）内部类可以有多个实例，每个实例都有自己的状态信息，并与其外围类对象的信息相互独立  
2）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类  
3）创建内部类对象的时刻并不依赖于外围类对象的创建  
4）内部类并没有令人迷惑的“is-a”关系，是一个独立的个体

- 闭包：是一个可调用的对象，记录了来自创建它的作用域的信息。比如内部类就是面向对象的闭包

- 回调的价值在于灵活性，可以在运行时动态地决定需要调用什么方法

- 控制框架是一类特殊的应用程序框架，用来解决响应事件的需求

- 继承内部类生成构造器时，必须在构造器使用如下语法：enclosingClassReference.super（）

- 局部内部类不能有访问说明符，因为不是外围类的一部分，但可以访问当前代码块和外围类的所有成员

- 使用局部内部类而不使用匿名内部类的理由：需要不止一个该内部类的对象，或者需要一个命名的构造器或者需要重载构造器

- .class文件包含了如何创建该类型的对象的全部信息，命名规则一般为 外围类的名字+“$”+内部类的名字
  
---

# 十二、持有对象  
    
- 容器的基本类型为List、Set、Queue和Map，也称为集合类

- 如果一个类没显式地声明继承自哪个类，那么自动地继承自Object

- 通过使用泛型，可以在编译期防止将错误类型的对象放置到容器中

- 当指定了某个类型作为泛型参数时，并不仅限于只能将该确切类型的对象放置到容器中，向上转型也可以作用于其他类型

- Java容器类类库的用途是保存对象，划分为两个不同的概念：Collection和Map

- LinkedList具有在List接口中未包含的额外方法，TreeMap具有在Map接口中未包含的方法

- Collection.addAll（）成员方法只能接受另一个Collection对象作为参数，不如Collections.addAll（）灵活，后者可为可变参数列表

- 可以在Arrays.asList（）中间插入一条“线索”，以告诉编译器对于由Arrays.asList（）产生的List类型，如 Arrays.<User>asList

- Collection和Map的区别之一在于Collection在每个槽中只能保存一个元素， Map在每个槽内保存了两个对象

- LinkedList包含的操作多于ArrayList

- HashMap和HashSet一样，提供了最快的查找技术，没有任何明显的顺序来保存元素

- TreeMap按比较结构进行升序保存键，LinkedHahMap按照插入顺序保存键，与此同时保留了HashMap的查询速度

- ArrayList在中间插入和移除元素较慢，LinkedList在随机访问方面相对比较慢

- subList（）所产生的列表的幕后就是初始列表，对返回列表的修改会反映到初始表中

- toArray（）方法，可以将任意的Collection转换为一个数组

- 迭代器是一个对象，工作是遍历并选择序列中的对象，也被称为轻量级对象

- Iterator只能单向移动，ListIterator可以双向移动（子类型，只能用于各类List的访问）

- 迭代器统一了对容器的访问方式，能够将遍历序列的操作与序列底层的结构分离

- LinkedList具有能直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用

- 查找是Set最重要的操作，不允许保存重复元素

- Set是基于对象的值来确定归属性的

- Hash使用了散列函数，TreeSet将元素存储在红黑树数据结构中，LinkedHashList因为查询速度的原因也采用了散列函数，但看起来像使用了链表维护

- TextFile工具可以打开一个文件，并读入一个Set中，具有较为强大的功能

- Map可以将容器组合起来从而快速地生成强大的数据结构

- 队列在并发编程中特别重要，可以安全地将对象从一个任务传输给另一个任务

- 队列Queue中，peek（）和element（）都将在不移除的情况下返回队头，但是peek（）方法在队列为空时返回null，而element（）会抛出NoSuchElementException异常；poll（）和remove（）同理

- 优先级队列PriorityQueue声明下一个弹出的元素是最需要的元素

- Collection是描述所有序列容器的共性的根接口

- 生成Iterator是将队列与消费队列的方法连接在一起耦合度最小的方式，并且与实现Collection相比，在序列类上所施加的约束也少得多

- foreach语法主要用于数组，但也可以应用于任何Collection对象

- 大量的类都是Iterable类型，主要包括所有的Collection类，但不包括Map

- foreach语句可以用于数据或其他任何Iterable，不代表数组也是Iterable，实际上任何自动包装也不会发生，不存在数组到Iterable的自动转换

- 除了TreeSet之外的所有的Set都拥有与Collection完全一样的接口

- Map与Collection之间唯一的重叠就是Map可以使用entrySet（）和value（）方法来产生Collection

- 简单的容器分类如下  
  
![预览图](https://github.com/Zhangxuan-Xing/Review/blob/master/Picture/Simple-1.png)  
  
   
![预览图](https://github.com/Zhangxuan-Xing/Review/blob/master/Picture/Simple-2.png)   
  
  
---

# 十三、异常处理  
  
- Java的基本理念是“结构不佳的代码不能运行”

- 发现错误的理想时机是编译阶段

- 改进的错误恢复机制时提供代码健壮性的最强有力的方式

- 异常处理是Java中唯一正式的错误报告机制，能降低错误处理代码的复杂度

- 异常机制能捕获错误，只需在一个地方处理错误，即所谓的异常处理程序中，将“正常执行过程做什么”和“出了问题怎么办”代码相分离

- 异常情形：阻止当前方法或作用域继续执行的问题

- 抛出异常后，同其他Java对象的创建一样，将使用new在堆上创建异常对象，当前的执行路径被终止，从当前环境中弹出对异常对象的引用

- 异常，不允许程序沿着正常路径继续走下去

- 关键字throw，在使用new创建对象之后，此对象的引用将传给throw，从效果上看，像是方法“返回”的，可以看成一种不同的返回机制

- 总是用new在堆上创建异常对象，伴随着存储空间的分配和构造器的调用，标准异常类都有两个构造器，一个是默认构造器，一个是接受字符串作为参数、以便把相关信息放入异常对象的构造器

- 监控区域：一段可能产生异常的代码

- catch关键字的字句与switch语句不同，switch语句需要break进行跳出

- 异常处理有两个基本模型，一个是终止模型，一个是恢复模型，大多数为前者

- 如果从已有的异常类继承，最好选择意思相近的异常类继承

- 如果我们需要捕获和记录其他人编写的异常，必须在异常处理程序中生成日志消息

- Java自顶向下的强制执行的异常说明机制，会提醒你要么处理这个异常，要么就在异常说明中表明此方法将产生异常

- printStackTrace（）方法所提供的信息可以通过getStackTrace（）方法来直接访问

- 重抛异常中，抛给上一级环境中的异常处理程序，同一个try块后续catch子句将被忽略

- 永远不必为清理前一个异常对象而担心，垃圾回收器会自动清理

- 异常链：在捕获一个异常后抛出另一个异常，并把原始异常的信息保存下来

- 在Throwable的子类中，只有三种基本的异常提供了带cause参数的构造器，为Error、Exception和RuntimeException

- Throwable用来表示任何可以作为异常被抛出的类，Throwable对象可分为两种类型：Error用来表示编译时和系统错误；Exception是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障都可能抛出Exception型异常

- 异常并非全是java.lang包里定义的，比如所有的输入/输出异常都是从java.io.IOExcption继承而来

- 属于运行时异常的类型有很多，会自动被Java虚拟机抛出，所以不必在异常说明中把它们列出来

- 如果RuntimException没有捕获而直达main（），那么在程序退出前将调用异常的printStackTrack（）方法

- 无论异常是否被抛出，finally子句总能被执行

- 异常作为程序出错的标志，决不应该被忽略，但还是有可能被忽略

- 异常限制对构造器不起作用，派生类构造器不能捕获基类构造器抛出的异常

- 派生类方法可以不抛出任何异常，即使是基类所定义的异常。对于派生类方法，“异常说明的接口”不是
变大反而是变小了，与类接口在继承时相反

- FileReader对象本身用处并不大，但可以用来创建BufferReader对象

- 异常处理系统会按照代码书写顺序找出“最近”的处理程序（派生类对象也可以），找到后，就不再继续查找

- 异常处理的一个重要目标是把错误处理的代码同错误发生的地点相分离，这样一来，主干代码就不会与错误处理逻辑混在一起，也更容易理解和维护

- 异常处理的优点之一是可以在某处集中精力处理要解决的问题，而在另一处处理你编写的这段代码中产生的错误  
  
---

# 十四、类型信息  
  
- 运行时类型信息可以在程序运行时发现和使用类型信息

- Java在运行时识别对象和类的信息主要有两种方式：①RTTI（在运行时，识别一个对象的类型），在编译时可以知道所有类型；②反射，在运行时发现和使用类的信息

- 数组，实际上将所有的事物都当做Object持有

- 多态机制中，希望大部分的代码尽可能少地了解对象的具体类型，而是只与对象家庭中的一个通用表示打交道

- Class对象就是用来创建类的所有的“常规”对象的，Java使用Class对象来执行其RTTI

- 类是程序的一部分，每个类都有一个Class对象，每当编写并且编译了一个新类，就会产生一个Class对象，运行这个程序的Java虚拟机将使用称为“类加载器”的子系统

- 原生加载器，是JVM实现的一部分，加载的是所谓的可信类，包括API类，通常从本地盘加载

- 所有的类都是在对其第一次使用时，动态加载到JVM的

- Java程序在它开始运行之前并非被完全加载，各个部分是在必需时才加载的

- 类加载器首先检查类的Class对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找.class文件，一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象

- Class.forName（）是取得Class对象的引用的一种方法，不需要为了获得Class引用而持有该类型的对象，生成的结果在编译时是不可知的

- 在传递给forName（）的字符串中，必须使用全限定名（包括包名）

- 想在运行时使用类型信息，就需要先获得对恰当的Class对象的引用，Class.forName（）是实现此功能的便捷途径，从而不需要为了获得Class引用而持有该类型的对象

- getName（）产生全限定的类名，getSimpleName（）产生不含包名的类名，getCanonicalName（）产生全限定的类名

- Class.getInterfaces（）方法返回的是Class对象

- 如果有一个Class对象，可以使用getSuperclass（）方法查询其基类信息

- 使用newInstance（）来创建的类，必须带有默认的构造器

- 可以使用类字面常量来生成对Class对象的引用，不仅可以应用于普通的类，也可以用于接口、数组以及基本数据类型

- Type字段是一个引用，指向对应的基本数据类型的Class对象

- 当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象（但为了产生Class引用，Class.forName（）会立即进行初始化），需要进行以下三部分：
1）加载：查找字节码，从字节码中创建一个Class对象  
2）链接：验证类中的字节码，为静态域分配存储空间，如果有需要，将解析这个类创建的对其他类的所有引用  
3）初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块

- 初始化被延迟到对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时执行

- 如果一个static final值是“编译期常量”，不需要对类进行初始化就可以读取；如果是一个域，不能确保这种行为

- 如果一个static域但不是final的，在对它访问时，总是要求在它被读取之前，先进行链接（分配存储空间）和初始化（初始化该存储空间）

- 通过泛型语法，可以让编译器强制执行额外的类型检查

- 在Java SE5中，Class<?>优于平凡的Class

- 如果将泛型语法用于Class对象，newInstance（）将返回对象的确切类型，但如果是超类，因为getSuperClass（）返回的是基类，编译器在编译期就不知道是什么类型了

- cast（）方法接受参数类型，将其转型为Class引用的类型

- RTTI的三种形式：  
1）传统的类型转换：确保类型转换的正确性，经常为“类型安全的向下转型”  
2）代表对象的类型的Class对象，通过查询获取运行时所需信息  
3）关键字instanceof，告诉我们对象是不是某个特定类型的实例

- 如果程序中编写了许多的instanceof，说明设计存在瑕疵

- Class.isInstance方法提供了一种动态测试对象的途径

- 协变返回类型，说白了就是运行返回更加具体的类

- instanceof保持了类型的概念，指的是“你是这个类吗，或者你是这个类的派生类吗”，如果用“==”比较实际的Class对象，就没有考虑继承，它或者是这个确切的类型，或者不是

- 某个对象的类型需在编译时已知，才能使用RTTI识别它

- 反射机制：用来检测可用的方法，并返回方法名

- Class类和java.lang.reflect类库对反射进行了支持（Filed、Method、Constructor应了解）

- RTTI和反射的区别：对于RTTI来说，编译器在编译时打开和检查.class文件；对于反射来说，.class文件在编译时是不可获取的，是在运行时打开和检查的

- 反射在Java中可以用来支持其他特性，如对象序列化和JavaBean

- 代理 ，为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象，充当“中间人”的角色

- 调用静态方法Proxy.newProxyInstance（）可以创建动态代理

- 空对象通常都是单例，可以接受传递给它的所代表的对象的信息，但是返回表示实际上并不存在任何“真实”对象的值

- 空对象的逻辑变体是模拟对象和桩，模拟对象往往是轻量级和自测试的，桩只是返回桩数据，往往是重量级的，并经常在测试之间被复用

- 对于域来说，没有任何方式可以阻止反射到达并调用那些非公访问权限的方法

- final域实际上在遭受修改时是安全的，运行时系统会在不抛异常的情况下接受任何修改尝试，但实际上不会发生任何修改
  
---

# 十五、泛型  
    
- final类或者具有private构造器的类不能扩展

- 多态算是一种泛化机制

- 一旦指明了接口，就要求代码必须使用特定的接口，会不够通用，希望能应用于“某种不确定的类型”，而不是一个具体的接口或类，从而也是泛型的意义

- 泛型：适用于许多许多的类型

- 泛型，在创建参数化类型的一个实例时，编译器会负责转型操作，并保证类型的正确性

- 泛型，可以用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性

- 与其使用Object，更推荐暂时不指定类型，而是稍后再决定具有使用说明类型

- 创建一个对象，用它来持有多个对象，就可以实现仅一次方法调用就能返回多个对象

- 元组：将一组对象之间打包存储于其中的一个单一对象。该对象允许读取其中元素，但不允许向其中存放新的元素（也称为数据传送对象，信使）

- 可以通过继承来实现长度更长的元组

- final声明能保护public元素，在对象被构造出来之后，声明为final的元素便不能被再赋予其他值了

- 泛型可以应用于接口，如生成器      

- 对于泛型，基本类型无法作为参数类型

- 可以在类中包含参数化方法，是否拥有泛型方法，与其所在的类是否是泛型没有关系

- 泛型方法能使得该方法独立于类而产生变化。无论何时，只要能做到，就应该尽量使用泛型方法

- 对于一个static的方法而言，无法访问泛型类的类型参数，所以如果static方法需要使用泛型能力的话，就必须使其成为泛型方法

- 使用泛型类时，必须在创建对象的时候指定类型参数的值；使用泛型方法时，不必指明参数类型

- 类型推断只对赋值操作有效，其他时候并不起作用

- 如果要显示地指明类型，必须在点操作符和方法名之间插入尖括号，并把类型置于尖括号之内。如果在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static方法，必须在点操作符之前加上类名

- 泛型方法与可变参数列表可以很好地共存

- 泛型可以应用于内部类和匿名内部类

- 在泛型代码内部，无法获得任何有关泛型参数类型的信息，将被擦除为它的第一个边界（可能会有多个边界），如List<String>变成List

- 当希望代码能跨过多个类工作时，使用泛型才有所帮助

- 泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上届

- 普通的类型变量在未指定边界的情况下，将被擦除为Object

- 擦除使得泛型不能显式地引用运行时类型的操作之中，例如转型、instanceof、new等，因为所有关于参数的信息都丢失了，只是看起来拥有参数类型信息而已，例如下方的f实例其实只是一个Object  
class Foo<T>{
  T var;
}  
Foo<Cat> f = new Foo<Cat>();  

- 如果想不仅仅当做Object处理，就需要管理边界

- 对于在泛型中创建数组，使用Array.newInstance（）是推荐的方式

- 即使擦除在方法或类内移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性，不知道T的信息，但能保证放置的对象具有T类型

- 泛型的动作发生在边界处，对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型

- new T（）无法实现，一部分原因是因为擦除，另一部分原因是编译期不能验证T具有默认构造器

- new Integer（）是错误的，Integer没有任何默认的构造器

- 一般情况下，不能创建泛型数组，一般解决方案是在任何想要创建泛型数组的地方使用ArrayList

- 成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型

- 因为擦除，数组在运行时的类型只能是Object

- 边界，可以用于泛型的参数类型上设置限制条件，可以按照自己的边界类型来调用方法

- Java泛型重用了extends关键字，在泛型边界上下文环境中和普通情况下所具有的意义是不一样的，强调了边界

- 基类数组可以引用导出类型的数组

- 泛型的主要目标之一是将错误检测移入到编译期

- 泛型拒绝向上转型，不能把一个涉及Apple的泛型赋给一个涉及Fruit的泛型

- 泛型没有内建的协变类型，泛型强调容器的类型，而不是容器持有的类型

- 编译期将拒绝对参数列表中涉及通配符的方法的调用

- 超类型通配符，可以声明通配符是由某个特定类的任何基类来界定的；不能对泛型参数给出一个超类型边界，即不能声明<T super MyClass>  

- 无界通配符<?>看起来意味着“任何事物”，可被认为是一种装饰，但仍旧有价值，并不是用原生类型，而是想说明可以持有任何类型  
比如 List实际上表示持有任何Object的原生List，而List<?>表示具有某种特定类型的非原生List，只是不知道类型是什么

- 无论何时，只要使用了原生类型，就会放弃编译期检查

- 使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但使用通配符可使得你必须接受范围更宽的参数化类型作为参数

- 任何基本类型都不能作为类型参数，解决之道是使用基本类型的包装器类

- 自动包装机制不能用于数组

- 一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会变成相同的接口

- 使用带有泛型类型参数的转型或者instanceof不会有任何的效果

- 由于擦除的原因，在泛型中，重载方法会产生相同的类型签名

- CRG：基类用导出类替代其参数。这意味着泛型基类变成了一种其所导出类的公共功能的模板，但对于其所有参数和返回值，将使用导出类型

- 自限定采取额外步骤，强制泛型当做其自己的边界参数来使用

- 自限定的参数可以保证类型必须与正在被定义的类相同

- 传递泛型容器，可以解决在这种强况下的类型检查问题，如静态方法checkedCollection（）、checkedList（）、checkedMap（）、checkedSet（）、checkedSortedMap（）和checkedSortedSet（）。受检查的容器在试图插入类型不正确的对象时，抛出ClassCastException

- catch不能捕获泛型类型的异常，因为需要知道异常的确切类型，也不能直接或间接继承自Throwable

- 混型，混合多个类的能力，以产生一个可以表示混型中所有类型的类

- 反射，将所有的类型检查都转移到了运行时

- 使用泛型机制最吸引人的地方，就是在使用容器类的地方

- 泛型，是一种方法，通过它可以写出更泛化的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个代码能应用到更多的类型上
  
---

# 十六、容器  
   
- 完整的容器分类图（包括抽象类和遗留构件，下图虚线框表示abstract类）
   
![预览图](https://github.com/Zhangxuan-Xing/Review/blob/master/Picture/FullContainerTaxonomy.png)   
  

- Collections类有一些实用的static方法，比如fill（）方法只复制同一个对象引用来填充整个容器，并且只对List对象有用；相对应的Collection的fill（）方法有限，只能替换已经在List中存在的方法，而不能添加新的元素

- java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架

- java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式

- 在自构Map的过程中，如果想使其成为只读的数据传输对象，可以使key和value域都是public和final的

- 享元模式可以使得对象的一部分被具体化，不需要将所有事物都包含在对象内部

- 每个java.util容器都有自己的abstract类，它们提供了容器的部分实现，创建定制版的时候，只需实现那些产生想要的容器的必需方法

- Map不是继承自Collection的

- Collection不包括随机访问所选择元素的get（）方法，因为包括Set

- Collection接口的可选操作，包括执行各种不同的添加和移除的方法，读取方法都不是可选的

- 将方法定义为可选，是为了防止在设计中出现接口爆炸的情况

- 接口（正式的interface关键字和任何类或子类支持的方法）是面向对象设计的契约，无论你选择如何实现该接口，都可以向该接口发送消息

- 动态语言可以在任何对象上调用任何方法，并可以在运行时发现某个特定调用是否可以工作

- 动态类型检查，指未获支持的操作只有在运行时才能探测到

- Arrays.asList（）会生成一个List，基于一个固定大小的数组，仅支持那些不会改变数组大小的操作。任何会引起对底层数据结构的尺寸进行修改的方法，都会产生一个UnsupportedOperationException异常，以表示对未获支持操作的调用

- Collections.unmodifiableList（）产生不可修改的列表

- Set中，散列和树型存储都会创建一个equals（）方法，但hashCode（）方法只有在HashSet（）和LinedHashSet（）才是必需的

- 对于良好的编程风格而言，在覆盖equals（）方法时，总是同时覆盖hashCode（）方法

- 在compareTo（）中，“简洁明了”的return i-i2，其实是一个常见的编程错误，对于Java的有符号int，不足以表示两个有符号的int的差，例如i是很大的正整数，j是很大的负整数，i-j就会溢出并返回赋值

- comparator（）返回null值，表示以自然方式排序

- SortedSet是按对象的比较函数对元素排序，而不是对插入次序进行排序

- 除了并发应用，Queue在Java中仅有的两个实现是LinedList和PriorityQueue

- 优先级队列有一个to-do列表，每个对象都包含一个字符串和一个主要的以及次要的优先级

- 在LinkedList中包含支持双向队列的方法，但是在Java标准类库中没有任何显式的用于双向队列的接口

- 映射表，也称为关联数组，其基本思想是维护键值对的关联

- 线性搜索是最慢的查询方式，HashMap使用了散列码来取代缓慢的搜索

- hashCode（）是根类Object中的方法，因此所有的Java对象都能产生散列码

- 散列是映射汇中存储元素时最常用的方式

- 使用sortedMap可以确保键处于排序状态

- LinkedHashMap采用最近最少使用（LRU）算法，对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易实现

- 使用Object的hashCode（）方法生成散列码，默认使用对象的地址计算散列码，不同的实例对象得到的散列码是不同的

- equals（）方法必须满足五个条件：  
1）自反性  
2）对称性  
3）传递性  
4）一致性  
5）对任何不是null的x，x.equals（null）一定返回false

- Object.equals（）只是比较对象的地址，因此如果把自己的类作为HashMap的键，必须同时重载hashCode（）和equals（），要区别比较对象的方法是否重写

- hashCode（）并不需要总是能够返回唯一的标识码，但是equals（）方法必须严格地判断两个对象是否相同

- 如果不覆盖hashCode（）和equals（），使用散列的数据结构就无法正确处理键

- 使用散列的目的在于想要用一个对象来查找另一个对象

- 散列的价值在于速度，使得查询可以快速进行

- 数组并不保存键本身，而是通过键对象生成一个数字，将其作为数组的下标，这个数字就是散列码

- 查询一个值的过程，首先是计算散列码，然后使用散列码查询数组

- 冲突由外部链接处理，数组不直接保存值，而是保存值的list

- 散列表的“槽位”，通常称为桶位，桶的数量通常使用质数

- 无法控制实际散列的数组（bucket）的下标值的产生，这个值依赖于具体的HashMap对象的容量，而容量的改变与容器的充满程度和负载因子有关

- 设计hashCode（）最重要的一点是对同一个对象调用方法时，都应该生成同样的值，也不应该使hashCode（）依赖于具有唯一性的对象信息，尤其是使用this的值

- 散列码不必独一无二，但通过hashCode（）和equals（），能完全确定对象的身份

- 好的hashCode（）应该产生分布均匀的散列码

- 四种容器：Map，List，Set和Queue。每种接口都有不止一种的实现版本

- Hashtable、Vector和Stack的特征，只是为了支持老的程序，已弃用

- 如果中间插入元素，ArrayList必须创建空间并将它所有引用向前移动， 尺寸增大会产生高昂的代价；LinkedList只需要链接新的元素，尺寸变化的影响不大

- CopyOnWriteArrayList是List的一个特殊实现，专用于并发编程

- HashSet的性能基本上总是比TreeSet好，特别是添加和查询元素时

- 对于插入操作，LinkedHashSet比HashSet的代价更高，这是由于维护链表所带来的额外开销导致

- 除了IdentityHashMap，所有Map实现的插入操作都会随着Map的尺寸越大而越慢

- IdentityHashMap具有完全不同的性能，因为它使用==而不是equals（）来比较元素

- Arrays.binarySearch（）在排序数组中快速查找对象

- HashMap的性能因子：  
1）容量：桶位数  
2）初始容量：表在创建时所拥有的桶位数  
3）尺寸：当前存储的项数  
4）负载因子：尺寸/容量

- 如果知道在HashMap中存储多少向，那么创建一个具有恰当大小的初始容量将可以避免自动再散列的开销

- 与使用数组进行查找和排序一样，如果使用Comparator进行排序，你们binarySearch（）必须使用相同的Comparator

- Collections的shuffle（）方法，用来打乱List的顺序

- Java容器类类库采用快速报错机制，探查容器上的任何除了你的进程所进行的操作之外的所有变化，一旦它发现其他进程修改了容器，就会立即抛出ConcurrentModificationException异常

- [持有引用]有三个继承自抽象类Reference的类：SoftReference、WeakReference和PhantomReference（依次由强到弱），为垃圾回收器提供了不同级别的间接性指示

- 普通的引用是指没有经Reference对象包装过的引用

- 使用使用SoftReference、WeakReference时，可以选择知否将它们放入ReferenceQueue，而PhantomReference只能依赖于ReferenceQueue

- WeakHashMap用来保存WeakReference，每个值只保存一份实例以节省存储空间。当程序需要那个值的时候，便在映射中查询现有的对象，然后使用它，是一种节约存储的技术

  
---

# 十七、I/O系统  
  
- 各种I/O源端和想要与之通信的接收端（文件、控制台、网络连接等），需要以多种不同的方式与它们进行通信（顺序、随机存取、缓冲、二进制、按字符、按行、按字等）

- File类，既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称，也可以用File对象来创建新的目录或尚不存在的整个目录路径，还可以查看文件的特性（如大小、修改日期、读写），检查某个File对象代表的是一个文件还是一个目录，并可以删除文件

- 匿名内部类通过创建特定的、一次性的类来解决问题，一方面，解决特定问题的代码隔离、聚拢于一点，另一方面，这种方法却不易阅读，要谨慎使用

- I/O类库中常使用流这个抽象概念，代表任何有能力产出数据的数据源对象或者有能力接收数据的接收端对象，“流”屏蔽了实际I/O设备中处理数据的细节

- I/O类库分为输入和输出两个部分

- 通过继承，任何自InputStream或Reader派生而来的类都含有名为read（）的基本方法，用于读取单个字节或字节数组；任何自OutputStream或Writer派生而来的类都含有名为writer（）的基本方法，用于写单个字节或字节数组

- InputStream的作用是用来表示那些从不同数据源产生输入的类，包括：  
1）字节数组  
2）String对象  
3）文件  
4）“管道”，从一端输入，从另一端输出  
5）一个由其他种类的流组成的序列  
6）其他数据源，如Internet连接等  
   
![预览图](https://github.com/Zhangxuan-Xing/Review/blob/master/Picture/inputStream.jpg)   
  

- OutputStream类决定了输出所要去往的目标：字节数组（但不是String）、文件或管道
   
![预览图](https://github.com/Zhangxuan-Xing/Review/blob/master/Picture/outputStream.jpg)   
  

- FilterInputStream和FilterOutputStream分别自I/O类库中的基类InputStream和OutputStream派生而来

- DataInputStream允许读取不同的基本类型数据以及String对象（所有方法都以read开头，如readByte（）、readFloat（）等等）  

- DataOutputStream可以将基本数据类型以及String对象格式化输出到流中，任何机器上的DataInputStream都能够读取它们，无论读和写的平台多么不同

- InputStream和OutputStream提供面向字节形式的I/O功能，Reader和Writer提供兼容Unicode与面向字符的I/O功能

- 设计Reader和Writer继承层次结构主要是为了国际化，为了在所有的I/O操作中都支持Unicode，比旧类操作也更快

- java.util.zip类是面向字节而不是面向字符的

- BufferedOutputStream是FilterOutputStream的子类，但BufferedWriter并不是FilterWriter的子类（FilterWriter是抽象类，没有任何子类）

- 无论何时使用readLine（），都不应该使用DataInputStream，而应该用BufferedReader。除了这一点，DataInputStream仍是I/O类库的首选成员

- PrintWriter构造器有一个“自动执行清空”的选项

- RandomAccessFile适用于由大小已知的记录组成的文件，可以在任何一个文件内向前和向后移动，在任何情况下，都是自我独立的，直接从Object派生而来。从本质上来说，其工作方式类似于把DataInputStream和DataOutputStream组合起来使用。支持搜寻方法，并只适用于文件

- [缓冲输入文件]打开一个文件用于字符输入，可以使用String或File对象作为文件名的FileInputReader，为了提高速度，希望进行缓冲，因而将所产生的引用传给一个BufferedReader构造器

- readLine（）返回null时，说明到达了文件的末尾

- [内存输入]BufferedInputFile.read（）每次读取一个字符

- DataInputStream的readByte（）一次一个字节地读取字符，available（）查看还有多少可供存取的字符

- 当使用DataOutputStream时，写字符串并且让DataInputStream能恢复的唯一可靠做法是使用UTF-8编码

- UTF-8是一种多字节格式，长度根据实际使用的字符集会有所变化，字符串的长度存储在UTF-8字符串的前两个字节中

- 为了保证所有的读写方法都能正常工作，要么为文件中的数据采用固定的格式，要么将额外的信息保存到文件中，以便能够对其进行解析以确定数据的存放位置。对象序列化和XML可能是更容易的存储和读取复杂数据结构的方式

- 管道流往往用于任务之间的通信

- read（）方法在读的时候，换行符会被去除掉

- 在任何打开文件的代码在finally子句中，作为防卫措施都添加了对文件的close（）调用，以保证文件将会被正确关闭

- 标准I/O：程序所使用的单一信息流。其意义在于我们可以很容易地把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入

- 在标准I/O模型中，Java提供了System.in、System.out和System.err

- System.out事先被包装成了printStream对象，System.err同样也是PrintStream，但System.in确是一个没有被包装过的未经加工的InputStream

- System.in与大多数流一样，通常应该对它进行缓冲

- PrintWriter如果不开启自动清空功能，可能会输出不全

- 对于想重复测试某个特定的输入序列的命令程序来说，重定向输入很有意义（System类提供的静态方法）

- I/O重定向操纵的是字节流，而不是字符流。因此，使用的是InputStream和OutputStream，而不是Writer和Reader

- JDK1.4 新I/O的速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式：通道和缓冲器

- 唯一直接与通道交互的缓冲器是ByteBuffer，可以存储未加工字节的缓冲器，可以输出和读取数据，没办法输出或读取对象

- 缓冲区(Buffer)：在Java NIO中负责数据的存取，缓冲区就是数组，用于存储不同数据类型的数据。根据数据类型不同(boolean除外)，提供了相应类型的缓冲区  
 * ByteBuffer
 * CharBuffer
 * ShortBuffer
 * IntBuffer
 * LongBuffer
 * FloatBuffer
 * DoubleBuffer  
 这些缓冲区的管理方式几乎一致，通过allocate()获取缓冲区  
**缓冲区存取数据的两个核心的方法：** 
 * put() 存入数据到缓冲区
 * get() 获取缓冲区的数据  
**缓冲区中的四个核心属性：**  
 * capacity:容量，表示缓冲区中最大的存储数据的容量，一旦声明不能改变
 * limit:界限，表示缓冲区中可以操作数据的大小。(limit后数据不能进行读写)
 * position：位置，表示缓冲区中正在操作数据的位置。
 *      0 <= mark <=   position <= limit <= capacity
 * mark:标记，表示记录当前position的位置，通过reset()恢复到mark的位置  
**直接缓冲区和非直接缓冲区**
 * 非直接缓冲区：通过allocate()分配缓冲区，将缓冲区建立在JVM的内存中
 * 直接缓冲区：通过allocateDirect()分配直接缓冲区，将缓冲区建立在物理内存中，可以提高效率。

- 缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入时进行编码，要么在转出时进行解码

- java.nio.charset.Charset提供了把数据编码成多种不同类型的字符集的工具

- ByteBuffer只能保存字节类型的数据，但可以从其所容纳的字节中产出各种不同基本类型值的方法

- 视图缓冲器：通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer，对视图的任何修改都会映射成为对ByteBuffer中数据的修改

- 使用视图缓冲器可以把任何数据都转化成某一特定的基本类型

- 当从不同类型的缓冲器读取时同一数据时，数据显示的方式也不同

- 不同的机器可能会使用不同的字节排序方法来存储数据，big endian（高位优先）将最重要的字节放在地址最低的存储器单元；little endian（低位优先）则相反。ByteBuffer以高位优先的形式存储数据结构

- ByteBuffer是将数据移进移出通道的唯一方式，因而总是以操纵ByteBuffer为目标

- JDK 1.4 引入了文件加锁机制，同步访问某个作为共享资源的文件

- [文件加锁]tryLock()是非阻塞式的，lock（）是阻塞式的-会阻塞进程直至锁可以获得，或调用lock（）的线程中断，或调用lock（）的通道关闭  
无参数的加锁方法根据文件尺寸变化而变化，具有固定尺寸的锁不会随文件的尺寸变化而变化  
锁的类型可以通过FileLock.isShared（）进行查询

- 文件映射通常应用于极大的文件，需要对这种巨大的文件进行部分加锁

- I/O类库的类支持读写压缩格式的数据流，按字节方式而不是字符方式进行处理

- GZIP接口非常简单，Zip库可以方便地保存多个文件。计算和校验的方法一般有两种，Adle32（快一些），CRC32（慢一点，但更准确）

- GZIP或Zip库的使用不仅仅局限于文件，可以压缩任何东西，包括需要通过网络发送的数据

- JAR文件可以加数字化签名

- 一个JAR文件由一组压缩文件构成，还有一张描述了所有这些文件的“文件清单”  

**对象序列化**

- 有时候，需要对象能够在程序不运行的情况下仍能存在并保存其信息

- Java的对象序列化，将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这
个字节序列完全恢复为原来的对象

- 对象的序列化，可以实现轻量级持久性，意味着一个对象的生存周期并不取决于程序是否正在执行，可以生存于程序调用之间，对象必须在程序中显式地序列化和反序列化

- 所有基本类型的封装器、所有容器类以及许多其他东西，甚至Class对象也可以被序列化

- 对象序列化是基于字节的，因而使用InputStream和OutputStream继承层次结构

- 对象序列化特别厉害的一个地方是它不仅仅保存了对象的“全景图”，而且能跟踪对象内所包含的所有引用，并保存那些对象，也称为“对象网”，单个对象可与之建立连接，还包含了对象的引用数组与成员对象

- 对一个Serializable对象进行还原的过程中，没有调用任何构造器，包括默认构造器，整个对象都是通过InputStream中取得数据恢复而来的

- 对于序列化的控制，可以通过实现Externalizable接口来实现，继承了Serializable接口，添加了writeExternal（）和readExternal（）方法，这两个方法在序列化和反序列化的过程中会被自动调用

- 对于Serializable对象，对象完全以它存储的二进制位为基础来构造，而不是调用构造器

- 如果从一个Extenaliable对象继承，通常需要调用基类版本的writeExternal（）和readExternal（）来为基类组件提供恰当的存储和恢复功能

- 即使对象中的信息是private，一经序列化处理，也可以通过读取文件或拦截网络传输的方式来访问

- transient（瞬时）关键字可以逐个字段地关闭序列化

- 重载后的+运算符连接String对象时，null引用会被字段转换成字符串null

- 序列化技术，存储程序的一些状态，以便我们随后可以很容易地将程序恢复到当前状态

- 通过一个字节数组来使用对象序列化，可以实现深度复制，意味着复制的是整个对象网，而不仅仅是基
本对象和引用

- 只要将任何对象序列化到单一流中，就可以恢复出与我们写出时一样的对象网，并且没有意外重复复制出的对象

- 序列化会把private数据保存下来，如果保证安全性，可以将其标记为transient  

**XML**

- 将数据转为XML，更具互操作性

- 如果文件结构与预期结构不匹配，XOM将抛出异常  

**Preferences**

- Preferences 可以自动存储和读取信息，只能存储基本类型和字符串，并且每个字符串的存储长度不能超过8k

- Preferences是一个键值集合（类似映射）

- 在不同的操作系统中，Preferences底层的存储方式是不一样的。例如，在Windows下是将数据存储在注册表中，而在Linux下则是将数据存储在文件系统中的。当然，对于程序员来说，这些都是透明的

- 在Preferences中，使用了树状结构来进行数据的存储，这主要是为了避免文件名冲突

  
---

# 十七、枚举  
  
- 关键字enum可以将一组具名的值的有限集合创建为一种新的类型，这些具名的值可以作为常规的程序组件使用

- 调用enum的values（）方法，可以遍历enum实例

- ordinal（）方法返回一个int值，这是美国enum实例在声明时的次序

- 在enum实例上调用getDeclaringClass（）方法，能知道其所属的enum类

- 使用static import能够将enum实例的标识符带入当前的命名空间  ，无需再用enum类型来修饰enum实例。在定义enum的同一个文件或默认包中，这种技巧无法使用

- 可以在enum中添加方法或属性，但必须先定义enum实例

- 一旦enum定义结束，编译器不允许再使用其构造器创建任何实例

- 在switch使用enum，是enum提供的一项非常便利的功能

- 编译器创建的enum类都继承自Enum类，values（）是由编译器添加的static方法。也因为如此，Java不支持多重继承，enum不能继承其他类

- 可以在一个接口的内部，创建该接口的枚举，以此将元素进行分类

- enum可以嵌套在另一个enum中，创建一个枚举的枚举

- enum要求成员都是唯一的

- EnumSet用来替代int的“位标志”，可以用来表示某种“开关”信息，将一个long值作为比特向量，非常快速高效，一个long值有64位，一个enum实例只需要一位bit表示其是否存在（在必要的时候，会增加一个long）

- EnumMap是一种特殊的Map，要求其中的键必需来自一个enum

- EnumSet、EnumMap都一样，enum实例定义时的次序决定了其的顺序

- 通过常量的方法，每个enum实例具有自己独特的行为，体现出多态的行为，但不能真的把enum实例作为一个类型来使用

- enum实例无法访问外部类的非static元素或方法，其行为与一般的内部类并不相同

- 职责链：程序员以多种方式来解决一个问题，将它们链接在一起，当一个请求到来时，遍历这个链，直到链中的某个解决方案能够处理该请求

- 枚举类型非常适合用来创建状态机，一个状态机可以具有有限个特定的状态，通常根据输入，从一个状态转移到下一个状态

- Java只支持单路分发，动态绑定机制只能处理其中的一个类型，如a.plus（b），并不能同时知道a和b的确切类型，从而不能正确交互，可以通过枚举实现多路分发（剪刀石头布 案例）

- 使用EnumMap能很好地实现两路分发
  
---

# 十七、注解  
  
- 注解（也称为 元数据）为在代码中添加信息提供了一种形式化的方法

- 注解把元数据与源代码文件结合在一起，提供用来完整地描述程序所需的信息，这些信息是无法用Java来表达的

- 注解可以实现更加干净易读的代码以及编译器类型检查等

- 注解是真正的语言级的概念，是在实际的源代码级别保存所有的信息，而不是某种注释性的文字

- 注解的使用方式几乎与修饰符的使用一模一样

- 没有元素的注解称为标记注解，如@Test

- 大多数时候，程序员主要是定义自己的注解，并编写自己的处理器来处理它们

- getAnnoation（）方法返回指定类型的注解对象，如果被注解的方法上没有该类型的注解，则返回null值

- 注解元素可以用的类型如下：  
1）所有基本类型（int，float，boolean等）  
2）String  
3）Class  
4）enum  
5）Annotation  
6）以上类型的数组

- 注解可以作为元素类型，也就是说，可以嵌套

- 注解元素不能有不确定的值，对于非基本类型的元素，都不能以null作为值，例如空字符串或负数，以表示某个元素不存在

- 注解不支持继承，不能使用关键字extends来继承某个@interface

- 注解处理工具apt，用于操作Java源文件，而不是编译后的类。默认情况下，apt会在处理完源文件后编译它们，会检查新生成的注解，然后将所有文件一同编译

- apt可以添加监听器，并在一轮注解处理过程结束的时候收到通知信息

- 使用apt生成的注解处理器时，无法利用Java反射机制，因为操作的是源代码，而不是编译后的类

- 单元测试是对类中的每个方法提供一个或多个测试的一种实践，目的是为了有规律地测试一个类的各个部分是否具备正确的行为

- 最著名的单元测试工具是JUnit，已融入注解

- 基于注解的测试框架叫做@Unit，测试方法可以是任意你喜欢的访问修饰方式，包括private

- 不一定要把测试方法嵌入到原本的类中，也可以通过继承或组合生成一个非嵌入式的测试

- @Unit中并没有JUnit里特殊的assert方法

- 对于每一个单元测试而言，@Unit都会用默认的构造器，为该测试所属的类创建出一个新的实例，并在此新创建的对象上运行测试，然后丢弃该对象，以避免对其他测试产生副作用

- 继承使得我们失去了访问被测试类中的private方法的能力

- 与JUnit相比，@Unit最大的优点就是不需要“套件”（因为会自动找到可测试的类和方法），当程序员在用的时候只需添加@Test   